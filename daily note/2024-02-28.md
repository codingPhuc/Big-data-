




Market Basket Model 
- Market a set of item 
- Basket group of item buy togheter by a customer 
A large set of items  
thing sold in a supermarket 


association rules : 
there are two side the left hand and right hand , 
{milk} ->  {coke}
customer buy item in the left hand side buy item in the right hand side 
`Frequent Itemset` find set of items that appear together 

`support`  for itemsset `I`  
Support for itemset I : number of baskets containing all items  in I 

Given  a `support` `threshold` s , then sets of items that apppers in at least s basket are called frequent itemsets 
![[bear and breadd.PNG]]
in the example above bread and bread seem to be in 2 different baseket so we conculde that  {beer , Bread  } =2  

{i1,  i2 ,  ... , ik} ->  j 

left hand side infer right hand side if customer by product in left hand side they are more likly to by stuff in the right hand side 




Confidence of association rule is the probability of j given     I  =  {i1  , ..,  ik}
Confidence is the proberbility of item from the left being bought given the boutgh item in the right 


![[confident.PNG]]
- confident equation 

P(I $/all$ {j}  )/  P(i ) =  P(j | I)
P(j| I) probertility of the cutomer taking all the item in the left when they have all the item in the right 


example : 
conf(milk -> bread) = 0.8  
the proberbility of a  customer buying bread given that they already bought milk  in this cases it is  80% 

Interest of an association rule I -> j : abs  difference between it confidence and the fraction of basket that contain j 

interest (I -> j) = | conf (I -> j ) - P(j)| 
interesting rules those with high interest values  (people is only interest in value that are above 0.5)

# Association Rule Minning 

Step 1: Find all frequent itemsets I
▪ (we will explain this next)
Step 2: Rule generation
▪ For every subset A of I, generate a rule A → I \ A
▪ Since I is frequent, A is also frequent
▪ Variant 1: Single pass to compute the rule confidence
▪ confidence(A,B→C,D) = support(A,B,C,D) / support(A,B)
▪ Variant 2:
▪ Observation:If A,B,C→D is below confidence, then so is A,B→C,D
▪ Can generate “bigger” rules from smaller ones!
▪ Output the rules above the confidence threshold

B1 = {m, c, b} B2 = {m, p, j}
B3 = {m, c, b, n} B4= {c, j}
B5 = {m, p, b} B6 = {m, c, b, j}
B7 = {c, b, j} B8 = {b, c}
 Support threshold s = 3, confidence c = 0.75
 Step 1) Find frequent itemsets:
▪ {b,m} {b,c} {c,m} {c,j} {m,c,b}
 Step 2) Generate rules:
▪ b→m: c=4/6 b→c: c=5/6 b,c→m: c=3/5
▪ m→b: c=4/5 ... b,m→c: c=3/4
b→c,m: c=3/6




# Computational model 


in pratice  passes  is one time we run over the entired dataset the compexity of an algorithm is bases on the number of passes the algorithm run 


![[triangle.PNG]]
this triangle represent a matric the matrix is a square it is a triagle is beacuase when split tha square matrix the trianagle on each side have the same value 
there are 2 type of matrix spares meaning the value in the matrix 


# A-Priori  ALogirthm 
A two pass approach 
Key ideal : monotonicity  
monotonicity mean that if I appears at least s times , so does every subject of  I

contrapositive : meaning if i is not in any basket that mean that all subset of i is not in the basket 
example : 
if i  is not in a basket then all subset of is like {i,a} will not be in the subset 



Pass 1: Read baskets and count in main memory  
the # of occurrences of each individual item  
▪ Requires only memory proportional to #items  
 Items that appear ≥ 𝒔 times are the frequent items  
 Pass 2: Read baskets again and keep track of the  
duyet qua basket tim support cho cac cap ma ca hai phan tu cua no deu pho bien 
count of only those pairs where both elements  
are frequent (from Pass 1)  
▪ Requires memory (for counts) proportional to square of  
the number of frequent items (not the square of total # of  
items)  
▪ Plus a list of the frequent items (so you know what must  
be counted)
![[A-priori.PNG]]
used  A priori for k pass for n number of element 



in python there is a hash() function that operate  very effectively 




# pCy  


in PCY  hash each pair to put into each bucket correcsponding to the hash value 
support of one basket equal to the support of pair value 

if one bucket is not common then all pair is too , thanh phan cung vay (sub) 

Pass 2 : 
only count pairs that hash to frequent buckets 